{
  "name": "rinadelph__agent-mcp",
  "display_name": "Agent-MCP",
  "description": "Agent-MCP is a framework for creating multi-agent systems that enables coordinated, efficient AI collaboration through the Model Context Protocol (MCP). The system is designed for developers building AI applications that benefit from multiple specialized agents working in parallel on different aspects of a project.",
  "author": {
    "name": "rinadelph"
  },
  "server": {
    "command": "python",
    "args": ["-m", "agent_mcp.cli", "--project-dir", "${user_config.project_dir}"],
    "env": {
      "OPENAI_API_KEY": "${user_config.openai_api_key}"
    },
    "type": "local"
  },
  "tools": [],
  "prompts": [],
  "keywords": [],
  "user_config": {
    "openai_api_key": {
      "type": "string",
      "title": "OpenAI API Key",
      "description": "Your OpenAI API key for accessing the OpenAI API.",
      "sensitive": true,
      "required": true
    },
    "project_dir": {
      "type": "directory",
      "title": "Project Directory",
      "description": "The root directory of your project where Agent-MCP will operate.",
      "required": true
    }
  },
  "readme": "# Agent-MCP\r\n\r\n[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/rinadelph/Agent-MCP)\r\n\r\n> ðŸš€ **Advanced Tool Notice**: This framework is designed for experienced AI developers who need sophisticated multi-agent orchestration capabilities. Agent-MCP requires familiarity with AI coding workflows, MCP protocols, and distributed systems concepts. We're actively working to improve documentation and ease of use. If you're new to AI-assisted development, consider starting with simpler tools and returning when you need advanced multi-agent capabilities.\r\n>\r\n> ðŸ’¬ **Join the Community**: Connect with us on [Discord](https://discord.gg/7Jm7nrhjGn) to get help, share experiences, and collaborate with other developers building multi-agent systems.\r\n\r\nMulti-Agent Collaboration Protocol for coordinated AI software development.\r\n\r\n<div align=\"center\">\r\n  <img src=\"assets/images/agent-network-viz.png\" alt=\"Agent Network Visualization\" width=\"600\">\r\n</div>\r\n\r\nThink **Obsidian for your AI agents** - a living knowledge graph where multiple AI agents collaborate through shared context, intelligent task management, and real-time visualization. Watch your codebase evolve as specialized agents work in parallel, never losing context or stepping on each other's work.\r\n\r\n## Why Multiple Agents?\r\n\r\nBeyond the philosophical issues, traditional AI coding assistants hit practical limitations:\r\n- **Context windows overflow** on large codebases\r\n- **Knowledge gets lost** between conversations\r\n- **Single-threaded execution** creates bottlenecks\r\n- **No specialization** - one agent tries to do everything\r\n- **Constant rework** from lost context and confusion\r\n\r\n## The Multi-Agent Solution\r\n\r\nAgent-MCP transforms AI development from a single assistant to a coordinated team:\r\n\r\n<div align=\"center\">\r\n  <img src=\"assets/images/dashboard-overview.png\" alt=\"Multi-Agent Collaboration Network\" width=\"800\">\r\n</div>\r\n\r\n**Real-time visualization** shows your AI team at work - purple nodes represent context entries, blue nodes are agents, and connections show active collaborations. It's like having a mission control center for your development team.\r\n\r\n### Core Capabilities\r\n\r\n**Parallel Execution**  \r\nMultiple specialized agents work simultaneously on different parts of your codebase. Backend agents handle APIs while frontend agents build UI components, all coordinated through shared memory.\r\n\r\n**Persistent Knowledge Graph**  \r\n\r\n<div align=\"center\">\r\n  <img src=\"assets/images/memory-bank.png\" alt=\"Memory Bank Interface\" width=\"800\">\r\n</div>\r\n\r\nYour project's entire context lives in a searchable, persistent memory bank. Agents query this shared knowledge to understand requirements, architectural decisions, and implementation details. Nothing gets lost between sessions.\r\n\r\n**Intelligent Task Management**  \r\n\r\n<div align=\"center\">\r\n  <img src=\"assets/images/agent-fleet.png\" alt=\"Agent Fleet Management\" width=\"800\">\r\n</div>\r\n\r\nMonitor every agent's status, assigned tasks, and recent activity. The system automatically manages task dependencies, prevents conflicts, and ensures work flows smoothly from planning to implementation.\r\n\r\n## Quick Start\r\n\r\n### Python Implementation (Recommended)\r\n\r\n```bash\r\n# Clone and setup\r\ngit clone https://github.com/rinadelph/Agent-MCP.git\r\ncd Agent-MCP\r\n\r\n# Check version requirements\r\npython --version  # Should be >=3.10\r\nnode --version    # Should be >=18.0.0\r\nnpm --version     # Should be >=9.0.0\r\n\r\n# If using nvm for Node.js version management\r\nnvm use  # Uses the version specified in .nvmrc\r\n\r\n# Configure environment\r\ncp .env.example .env  # Add your OpenAI API key\r\nuv venv\r\nuv install\r\n\r\n# Start the server\r\nuv run -m agent_mcp.cli --port 8080 --project-dir path-to-directory\r\n\r\n# Launch dashboard (recommended for full experience)\r\ncd agent_mcp/dashboard && npm install && npm run dev\r\n```\r\n\r\n### Node.js/TypeScript Implementation (Alternative)\r\n\r\n```bash\r\n# Clone and setup\r\ngit clone https://github.com/rinadelph/Agent-MCP.git\r\ncd Agent-MCP/agent-mcp-node\r\n\r\n# Install dependencies\r\nnpm install\r\n\r\n# Configure environment\r\ncp .env.example .env  # Add your OpenAI API key\r\n\r\n# Start the server\r\nnpm run server\r\n\r\n# Or use the built version\r\nnpm run build\r\nnpm start\r\n\r\n# Or install globally\r\nnpm install -g agent-mcp-node\r\nagent-mcp --port 8080 --project-dir path-to-directory\r\n```\r\n\r\n## MCP Integration Guide\r\n\r\n### What is MCP?\r\n\r\nThe **Model Context Protocol (MCP)** is an open standard that enables AI assistants to securely connect to external data sources and tools. Agent-MCP leverages MCP to provide seamless integration with various development tools and services.\r\n\r\n### Running Agent-MCP as an MCP Server\r\n\r\nAgent-MCP can function as an MCP server, exposing its multi-agent capabilities to MCP-compatible clients like Claude Desktop, Cline, and other AI coding assistants.\r\n\r\n#### Quick MCP Setup\r\n\r\n```bash\r\n# 1. Install Agent-MCP\r\nuv venv\r\nuv install\r\n\r\n# 2. Start the MCP server\r\nuv run -m agent_mcp.cli --port 8080\r\n\r\n# 3. Configure your MCP client to connect to:\r\n# HTTP: http://localhost:8000/mcp\r\n# WebSocket: ws://localhost:8000/mcp/ws\r\n```\r\n\r\n#### MCP Server Configuration\r\n\r\nCreate an MCP configuration file (`mcp_config.json`):\r\n\r\n```json\r\n{\r\n  \"server\": {\r\n    \"name\": \"agent-mcp\",\r\n    \"version\": \"1.0.0\"\r\n  },\r\n  \"tools\": [\r\n    {\r\n      \"name\": \"create_agent\",\r\n      \"description\": \"Create a new specialized AI agent\"\r\n    },\r\n    {\r\n      \"name\": \"assign_task\", \r\n      \"description\": \"Assign tasks to specific agents\"\r\n    },\r\n    {\r\n      \"name\": \"query_project_context\",\r\n      \"description\": \"Query the shared knowledge graph\"\r\n    },\r\n    {\r\n      \"name\": \"manage_agent_communication\",\r\n      \"description\": \"Handle inter-agent messaging\"\r\n    }\r\n  ],\r\n  \"resources\": [\r\n    {\r\n      \"name\": \"agent_status\",\r\n      \"description\": \"Real-time agent status and activity\"\r\n    },\r\n    {\r\n      \"name\": \"project_memory\",\r\n      \"description\": \"Persistent project knowledge graph\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n#### Using Agent-MCP with Claude Desktop\r\n\r\n1. **Add to Claude Desktop Config**:\r\n   \r\n   Open `~/Library/Application Support/Claude/claude_desktop_config.json` (macOS) or equivalent:\r\n   \r\n   ```json\r\n   {\r\n     \"mcpServers\": {\r\n       \"agent-mcp\": {\r\n         \"command\": \"uv\",\r\n         \"args\": [\"run\", \"-m\", \"agent_mcp.cli\", \"--port\", \"8080\"],\r\n         \"env\": {\r\n           \"OPENAI_API_KEY\": \"your-openai-api-key\"\r\n         }\r\n       }\r\n     }\r\n   }\r\n   ```\r\n\r\n2. **Restart Claude Desktop** to load the MCP server\r\n\r\n3. **Verify Connection**: Claude should show \"ðŸ”Œ agent-mcp\" in the conversation\r\n\r\n#### MCP Tools Available\r\n\r\nOnce connected, you can use these MCP tools directly in Claude:\r\n\r\n**Agent Management**\r\n- `create_agent` - Spawn specialized agents (backend, frontend, testing, etc.)\r\n- `list_agents` - View all active agents and their status\r\n- `terminate_agent` - Safely shut down agents\r\n\r\n**Task Orchestration**  \r\n- `assign_task` - Delegate work to specific agents\r\n- `view_tasks` - Monitor task progress and dependencies\r\n- `update_task_status` - Track completion and blockers\r\n\r\n**Knowledge Management**\r\n- `ask_project_rag` - Query the persistent knowledge graph\r\n- `update_project_context` - Add architectural decisions and patterns\r\n- `view_project_context` - Access stored project information\r\n\r\n**Communication**\r\n- `send_agent_message` - Direct messaging between agents\r\n- `broadcast_message` - Send updates to all agents\r\n- `request_assistance` - Escalate complex issues\r\n\r\n#### Advanced MCP Configuration\r\n\r\n**Custom Transport Options**:\r\n```bash\r\n# HTTP with custom port\r\nuv run -m agent_mcp.cli --port 8080\r\n\r\n# WebSocket with authentication\r\nuv run -m agent_mcp.cli --port 8080 --auth-token your-secret-token\r\n\r\n# Unix socket (Linux/macOS)\r\nuv run -m agent_mcp.cli --port 8080\r\n```\r\n\r\n**Environment Variables**:\r\n```bash\r\nexport AGENT_MCP_HOST=0.0.0.0          # Server host\r\nexport AGENT_MCP_PORT=8000              # Server port  \r\nexport AGENT_MCP_LOG_LEVEL=INFO         # Logging level\r\nexport AGENT_MCP_PROJECT_DIR=/your/project  # Default project directory\r\nexport AGENT_MCP_MAX_AGENTS=10          # Maximum concurrent agents\r\n```\r\n\r\n### MCP Client Examples\r\n\r\n#### Python Client\r\n```python\r\nimport asyncio\r\nfrom mcp import Client\r\n\r\nasync def main():\r\n    async with Client(\"http://localhost:8000/mcp\") as client:\r\n        # Create a backend agent\r\n        result = await client.call_tool(\"create_agent\", {\r\n            \"role\": \"backend\",\r\n            \"specialization\": \"API development\"\r\n        })\r\n        \r\n        # Assign a task\r\n        await client.call_tool(\"assign_task\", {\r\n            \"agent_id\": result[\"agent_id\"],\r\n            \"task\": \"Implement user authentication endpoints\"\r\n        })\r\n        \r\n        # Query project context\r\n        context = await client.call_tool(\"ask_project_rag\", {\r\n            \"query\": \"What's our current database schema?\"\r\n        })\r\n        print(context)\r\n\r\nasyncio.run(main())\r\n```\r\n\r\n#### JavaScript Client\r\n```javascript\r\nimport { MCPClient } from '@modelcontextprotocol/client';\r\n\r\nconst client = new MCPClient('http://localhost:8000/mcp');\r\n\r\nasync function createAgent() {\r\n  await client.connect();\r\n  \r\n  const agent = await client.callTool('create_agent', {\r\n    role: 'frontend',\r\n    specialization: 'React components'\r\n  });\r\n  \r\n  console.log('Created agent:', agent.agent_id);\r\n  \r\n  await client.disconnect();\r\n}\r\n\r\ncreateAgent().catch(console.error);\r\n```\r\n\r\n### Troubleshooting MCP Connection\r\n\r\n**Connection Issues**:\r\n```bash\r\n# Check if MCP server is running\r\ncurl http://localhost:8000/mcp/health\r\n\r\n# Verify WebSocket connection\r\nwscat -c ws://localhost:8000/mcp/ws\r\n\r\n# Check server logs\r\nuv run -m agent_mcp.cli --port 8080 --log-level DEBUG\r\n```\r\n\r\n**Common Issues**:\r\n- **Port conflicts**: Change port with `--port` flag\r\n- **Permission errors**: Ensure OpenAI API key is set\r\n- **Client timeout**: Increase timeout in client configuration\r\n- **Agent limit reached**: Check active agent count with `list_agents`\r\n\r\n### Integration Examples\r\n\r\n**VS Code with MCP**:\r\nUse the MCP extension to integrate Agent-MCP directly into your editor workflow.\r\n\r\n**Terminal Usage**:\r\n```bash\r\n# Quick task assignment via curl\r\ncurl -X POST http://localhost:8000/mcp/tools/assign_task \\\r\n  -H \"Content-Type: application/json\" \\\r\n  -d '{\"task\": \"Add error handling to API endpoints\", \"agent_role\": \"backend\"}'\r\n```\r\n\r\n**CI/CD Integration**:\r\n```yaml\r\n# GitHub Actions example\r\n- name: Run Agent-MCP Code Review\r\n  run: |\r\n    uv run -m agent_mcp.cli --port 8080 --daemon\r\n    curl -X POST localhost:8000/mcp/tools/assign_task \\\r\n      -d '{\"task\": \"Review PR for security issues\", \"agent_role\": \"security\"}'\r\n```\r\n\r\n## How It Works: Breaking Complexity into Simple Steps\r\n\r\n```mermaid\r\ngraph LR\r\n    A[Step 1] --> B[Step 2] --> C[Step 3] --> D[Step 4] --> E[Done!]\r\n    style A fill:#4ecdc4,color:#fff\r\n    style E fill:#ff6b6b,color:#fff\r\n```\r\n\r\nEvery task can be broken down into linear steps. This is the core insight that makes Agent-MCP powerful.\r\n\r\n### The Problem with Complex Tasks\r\n\r\n```mermaid\r\ngraph TD\r\n    A[\"Build User Authentication\"] -->|Single Agent Tries Everything| B{???}\r\n    B --> C[Database?]\r\n    B --> D[API?]\r\n    B --> E[Frontend?]\r\n    B --> F[Security?]\r\n    B --> G[Tests?]\r\n    C -.->|Confused| H[Incomplete Implementation]\r\n    D -.->|Overwhelmed| H\r\n    E -.->|Context Lost| H\r\n    F -.->|Assumptions| H\r\n    G -.->|Forgotten| H\r\n    style A fill:#ff6b6b,color:#fff\r\n    style H fill:#666,color:#fff\r\n```\r\n\r\n### The Agent-MCP Solution\r\n\r\n```mermaid\r\ngraph TD\r\n    A[\"Build User Authentication\"] -->|Break Down| B[Linear Tasks]\r\n    B --> C[\"Agent 1: Database\"]\r\n    B --> D[\"Agent 2: API\"]\r\n    B --> E[\"Agent 3: Frontend\"]\r\n    \r\n    C --> C1[Create users table]\r\n    C1 --> C2[Add indexes]\r\n    C2 --> C3[Create sessions table]\r\n    \r\n    D --> D1[POST /register]\r\n    D1 --> D2[POST /login]\r\n    D2 --> D3[POST /logout]\r\n    \r\n    E --> E1[Login Form]\r\n    E1 --> E2[Register Form]\r\n    E2 --> E3[Auth Context]\r\n    \r\n    C3 --> F[Working System]\r\n    D3 --> F\r\n    E3 --> F\r\n    \r\n    style A fill:#4ecdc4,color:#fff\r\n    style F fill:#4ecdc4,color:#fff\r\n```\r\n\r\nEach agent focuses on their linear chain. No confusion. No context pollution. Just clear, deterministic progress.\r\n\r\n## The 5-Step Workflow\r\n\r\n### 1. Initialize Admin Agent\r\n```\r\nYou are the admin agent.\r\nAdmin Token: \"your_admin_token_from_server\"\r\n\r\nYour role is to:\r\n- Coordinate all development work\r\n- Create and manage worker agents\r\n- Maintain project context\r\n- Assign tasks based on agent specializations\r\n```\r\n\r\n### 2. Load Your Project Blueprint (MCD)\r\n```\r\nAdd this MCD (Main Context Document) to project context:\r\n\r\n[paste your MCD here - see docs/mcd-guide.md for structure]\r\n\r\nStore every detail in the knowledge graph. This becomes the single source of truth for all agents.\r\n```\r\n\r\nThe MCD (Main Context Document) is your project's comprehensive blueprint - think of it as writing the book of your application before building it. It includes:\r\n- Technical architecture and design decisions\r\n- Database schemas and API specifications\r\n- UI component hierarchies and workflows\r\n- Task breakdowns with clear dependencies\r\n\r\nSee our [MCD Guide](./docs/mcd-guide.md) for detailed examples and templates.\r\n\r\n### 3. Deploy Your Agent Team\r\n```\r\nCreate specialized agents for parallel development:\r\n\r\n- backend-worker: API endpoints, database operations, business logic\r\n- frontend-worker: UI components, state management, user interactions\r\n- integration-worker: API connections, data flow, system integration\r\n- test-worker: Unit tests, integration tests, validation\r\n- devops-worker: Deployment, CI/CD, infrastructure\r\n```\r\n\r\nEach agent specializes in their domain, leading to higher quality implementations and faster development.\r\n\r\n### 4. Initialize and Deploy Workers\r\n```\r\n# In new window for each worker:\r\nYou are [worker-name] agent.\r\nYour Admin Token: \"worker_token_from_admin\"\r\n\r\nQuery the project knowledge graph to understand:\r\n1. Overall system architecture\r\n2. Your specific responsibilities\r\n3. Integration points with other components\r\n4. Coding standards and patterns to follow\r\n5. Current implementation status\r\n\r\nBegin implementation following the established patterns.\r\n\r\nAUTO --worker --memory\r\n```\r\n\r\n**Important: Setting Agent Modes**\r\n\r\nAgent modes (like `--worker`, `--memory`, `--playwright`) are not just flags - they activate specific behavioral patterns. In Claude Code, you can make these persistent by:\r\n\r\n1. Copy the mode instructions to your clipboard\r\n2. Type `#` to open Claude's memory feature\r\n3. Paste the instructions for persistent behavior\r\n\r\nExample for Claude Code memory:\r\n```\r\n# When I use \"AUTO --worker --memory\", follow these patterns:\r\n- Always check file status before editing\r\n- Query project RAG for context before implementing\r\n- Document all changes in task notes\r\n- Work on one file at a time, completing it before moving on\r\n- Update task status after each completion\r\n```\r\n\r\nThis ensures consistent behavior across your entire session without repeating instructions.\r\n\r\n### 5. Monitor and Coordinate\r\n\r\nThe dashboard provides real-time visibility into your AI development team:\r\n\r\n**Network Visualization** - Watch agents collaborate and share information  \r\n**Task Progress** - Track completion across all parallel work streams  \r\n**Memory Health** - Ensure context remains fresh and accessible  \r\n**Activity Timeline** - See exactly what each agent is doing\r\n\r\nAccess at `http://localhost:3847` after launching the dashboard.\r\n\r\n## Advanced Features\r\n\r\n### Specialized Agent Modes\r\n\r\nAgent modes fundamentally change how agents behave. They're not just configuration - they're behavioral contracts that ensure agents follow specific patterns optimized for their role.\r\n\r\n**Standard Worker Mode**\r\n```\r\nAUTO --worker --memory\r\n```\r\nOptimized for implementation tasks:\r\n- Granular file status checking before any edits\r\n- Sequential task completion (one at a time)\r\n- Automatic documentation of changes\r\n- Integration with project RAG for context\r\n- Task status updates after each completion\r\n\r\n**Frontend Specialist Mode**\r\n```\r\nAUTO --worker --playwright\r\n```\r\nEnhanced with visual validation capabilities:\r\n- All standard worker features\r\n- Browser automation for component testing\r\n- Screenshot capabilities for visual regression\r\n- DOM interaction for end-to-end testing\r\n- Component-by-component implementation with visual verification\r\n\r\n**Research Mode**\r\n```\r\nAUTO --memory\r\n```\r\nRead-only access for analysis and planning:\r\n- No file modifications allowed\r\n- Deep context exploration via RAG\r\n- Pattern identification across codebase\r\n- Documentation generation\r\n- Architecture analysis and recommendations\r\n\r\n**Memory Management Mode**\r\n```\r\nAUTO --memory --manager\r\n```\r\nFor context curation and optimization:\r\n- Memory health monitoring\r\n- Stale context identification\r\n- Knowledge graph optimization\r\n- Context summarization for new agents\r\n- Cross-agent knowledge transfer\r\n\r\nEach mode enforces specific behaviors that prevent common mistakes and ensure consistent, high-quality output.\r\n\r\n### Project Memory Management\r\n\r\nThe system maintains several types of memory:\r\n\r\n**Project Context** - Architectural decisions, design patterns, conventions  \r\n**Task Memory** - Current status, blockers, implementation notes  \r\n**Agent Memory** - Individual agent learnings and specializations  \r\n**Integration Points** - How different components connect\r\n\r\nAll memory is:\r\n- Searchable via semantic queries\r\n- Version controlled for rollback\r\n- Tagged for easy categorization\r\n- Automatically garbage collected when stale\r\n\r\n### Conflict Resolution\r\n\r\nFile-level locking prevents agents from overwriting each other's work:\r\n\r\n1. Agent requests file access\r\n2. System checks if file is locked\r\n3. If locked, agent works on other tasks or waits\r\n4. After completion, lock is released\r\n5. Other agents can now modify the file\r\n\r\nThis happens automatically - no manual coordination needed.\r\n\r\n## Short-Lived vs. Long-Lived Agents: The Critical Difference\r\n\r\n### Traditional Long-Lived Agents\r\nMost AI coding assistants maintain conversations across entire projects:\r\n- **Accumulated context grows unbounded** - mixing unrelated code, decisions, and conversations\r\n- **Confused priorities** - yesterday's bug fix mingles with today's feature request\r\n- **Hallucination risks increase** - agents invent connections between unrelated parts\r\n- **Performance degrades over time** - every response processes irrelevant history\r\n- **Security vulnerability** - one carefully crafted prompt could expose your entire project\r\n\r\n### Agent-MCP's Ephemeral Agents\r\nEach agent is purpose-built for a single task:\r\n- **Minimal, focused context** - only what's needed for the specific task\r\n- **Crystal clear objectives** - one task, one goal, no ambiguity\r\n- **Deterministic behavior** - limited context means predictable outputs\r\n- **Consistently fast responses** - no context bloat to slow things down\r\n- **Secure by design** - agents literally cannot access what they don't need\r\n\r\n### A Practical Example\r\n\r\n**Traditional Approach**: \"Update the user authentication system\"\r\n```\r\nAgent: I'll update your auth system. I see from our previous conversation about \r\ndatabase migrations, UI components, API endpoints, deployment scripts, and that \r\nbug in the payment system... wait, which auth approach did we decide on? Let me \r\ntry to piece this together from our 50+ message history...\r\n\r\n[Agent produces confused implementation mixing multiple patterns]\r\n```\r\n\r\n**Agent-MCP Approach**: Same request, broken into focused tasks\r\n```\r\nAgent 1 (Database): Create auth tables with exactly these fields...\r\nAgent 2 (API): Implement /auth endpoints following REST patterns...\r\nAgent 3 (Frontend): Build login forms using existing component library...\r\nAgent 4 (Tests): Write auth tests covering these specific scenarios...\r\nAgent 5 (Integration): Connect components following documented interfaces...\r\n\r\n[Each agent completes their specific task without confusion]\r\n```\r\n\r\n## The Theory Behind Linear Decomposition\r\n\r\n### The Philosophy: Short-Lived Agents, Granular Tasks\r\n\r\nMost AI development approaches suffer from a fundamental flaw: they try to maintain massive context windows with a single, long-running agent. This leads to:\r\n\r\n- **Context pollution** - Irrelevant information drowns out what matters\r\n- **Hallucination risks** - Agents invent connections between unrelated parts\r\n- **Security vulnerabilities** - Agents with full context can be manipulated\r\n- **Performance degradation** - Large contexts slow down reasoning\r\n- **Unpredictable behavior** - Too much context creates chaos\r\n\r\n### Our Solution: Ephemeral Agents with Shared Memory\r\n\r\nAgent-MCP implements a radically different approach:\r\n\r\n**Short-Lived, Focused Agents**  \r\nEach agent lives only as long as their specific task. They:\r\n- Start with minimal context (just what they need)\r\n- Execute granular, linear tasks with clear boundaries\r\n- Document their work in shared memory\r\n- Terminate upon completion\r\n\r\n**Shared Knowledge Graph (RAG)**  \r\nInstead of cramming everything into context windows:\r\n- Persistent memory stores all project knowledge\r\n- Agents query only what's relevant to their task\r\n- Knowledge accumulates without overwhelming any single agent\r\n- Clear separation between working memory and reference material\r\n\r\n**Result**: Agents that are fast, focused, and safe. They can't be manipulated to reveal full project details because they never have access to it all at once.\r\n\r\n### Why This Matters for Safety\r\n\r\nTraditional long-context agents are like giving someone your entire codebase, documentation, and secrets in one conversation. Our approach is like having specialized contractors who only see the blueprint for their specific room.\r\n\r\n- **Reduced attack surface** - Agents can't leak what they don't know\r\n- **Deterministic behavior** - Limited context means predictable outputs\r\n- **Audit trails** - Every agent action is logged and traceable\r\n- **Rollback capability** - Mistakes are isolated to specific tasks\r\n\r\n### The Cleanup Protocol: Keeping Your System Lean\r\n\r\nAgent-MCP enforces strict lifecycle management:\r\n\r\n**Maximum 10 Active Agents**\r\n- Hard limit prevents resource exhaustion\r\n- Forces thoughtful task allocation\r\n- Maintains system performance\r\n\r\n**Automatic Cleanup Rules**\r\n- Agent finishes task â†’ Immediately terminated\r\n- Agent idle 60+ seconds â†’ Killed and task reassigned\r\n- Need more than 10 agents â†’ Least productive agents removed\r\n\r\n**Why This Matters**\r\n- **No zombie processes** eating resources\r\n- **Fresh context** for every task\r\n- **Predictable resource usage**\r\n- **Clean system state** always\r\n\r\nThis isn't just housekeeping - it's fundamental to the security and performance benefits of the short-lived agent model.\r\n\r\n### The Fundamental Principle\r\n\r\n**Any task that cannot be expressed as `Step 1 â†’ Step 2 â†’ Step N` is not atomic enough.**\r\n\r\nThis principle drives everything in Agent-MCP:\r\n\r\n1. **Complex goals** must decompose into **linear sequences**\r\n2. **Linear sequences** can execute **in parallel** when independent\r\n3. **Each step** must have **clear prerequisites** and **deterministic outputs**\r\n4. **Integration points** are **explicit** and **well-defined**\r\n\r\n### Why Linear Decomposition Works\r\n\r\n**Traditional Approach**: \"Build a user authentication system\"\r\n- Vague requirements lead to varied implementations\r\n- Agents make different assumptions\r\n- Integration becomes a nightmare\r\n\r\n**Agent-MCP Approach**: \r\n```\r\nChain 1: Database Layer\r\n  1.1: Create users table with id, email, password_hash\r\n  1.2: Add unique index on email\r\n  1.3: Create sessions table with user_id, token, expiry\r\n  1.4: Write migration scripts\r\n  \r\nChain 2: API Layer  \r\n  2.1: Implement POST /auth/register endpoint\r\n  2.2: Implement POST /auth/login endpoint\r\n  2.3: Implement POST /auth/logout endpoint\r\n  2.4: Add JWT token generation\r\n  \r\nChain 3: Frontend Layer\r\n  3.1: Create AuthContext provider\r\n  3.2: Build LoginForm component\r\n  3.3: Build RegisterForm component\r\n  3.4: Implement protected routes\r\n```\r\n\r\nEach step is atomic, testable, and has zero ambiguity. Multiple agents can work these chains in parallel without conflict.\r\n\r\n## Why Developers Choose Agent-MCP\r\n\r\n**The Power of Parallel Development**  \r\nInstead of waiting for one agent to finish the backend before starting the frontend, deploy specialized agents to work simultaneously. Your development speed is limited only by how well you decompose tasks.\r\n\r\n**No More Lost Context**  \r\nEvery decision, implementation detail, and architectural choice is stored in the shared knowledge graph. New agents instantly understand the project state without reading through lengthy conversation histories.\r\n\r\n**Predictable, Reliable Outputs**  \r\nFocused agents with limited context produce consistent results. The same task produces the same quality output every time, making development predictable and testable.\r\n\r\n**Built-in Conflict Prevention**  \r\nFile-level locking and task assignment prevent agents from stepping on each other's work. No more merge conflicts from simultaneous edits.\r\n\r\n**Complete Development Transparency**  \r\nWatch your AI team work in real-time through the dashboard. Every action is logged, every decision traceable. It's like having a live view into your development pipeline.\r\n\r\n**For Different Team Sizes**\r\n\r\n**Solo Developers**: Transform one AI assistant into a coordinated team. Work on multiple features simultaneously without losing track.\r\n\r\n**Small Teams**: Augment human developers with AI specialists that maintain perfect context across sessions.\r\n\r\n**Large Projects**: Handle complex systems where no single agent could hold all the context. The shared memory scales infinitely.\r\n\r\n**Learning & Teaching**: Perfect for understanding software architecture. Watch how tasks decompose and integrate in real-time.\r\n\r\n## System Requirements\r\n\r\n- **Python**: 3.10+ with pip or uv\r\n- **Node.js**: 18.0.0+ (recommended: 22.16.0)\r\n- **npm**: 9.0.0+ (recommended: 10.9.2)\r\n- **OpenAI API key** (for embeddings and RAG)\r\n- **RAM**: 4GB minimum\r\n- **AI coding assistant**: Claude Code or Cursor\r\n\r\nFor consistent development environment:\r\n```bash\r\n# Using nvm (Node Version Manager)\r\nnvm use  # Automatically uses Node v22.16.0 from .nvmrc\r\n\r\n# Or manually check versions\r\nnode --version  # Should be >=18.0.0\r\nnpm --version   # Should be >=9.0.0\r\npython --version  # Should be >=3.10\r\n```\r\n\r\n## Troubleshooting\r\n\r\n**\"Admin token not found\"**  \r\nCheck the server startup logs - token is displayed when MCP server starts.\r\n\r\n**\"Worker can't access tasks\"**  \r\nEnsure you're using the worker token (not admin token) when initializing workers.\r\n\r\n**\"Agents overwriting each other\"**  \r\nVerify all workers are initialized with the `--worker` flag for proper coordination.\r\n\r\n**\"Dashboard connection failed\"**  \r\n1. Ensure MCP server is running first\r\n2. Check Node.js version (18+ required)\r\n3. Reinstall dashboard dependencies\r\n\r\n**\"Memory queries returning stale data\"**  \r\nRun memory garbage collection through the dashboard or restart with `--refresh-memory`.\r\n\r\n## Documentation\r\n\r\n- [Getting Started Guide](./docs/getting-started.md) - Complete walkthrough with examples\r\n- [MCD Creation Guide](./docs/mcd-guide.md) - Write effective project blueprints\r\n- [Theoretical Foundation](./docs/chapter-1-cognitive-empathy.md) - Understanding AI cognition\r\n- [Architecture Overview](./docs/architecture.md) - System design and components\r\n- [API Reference](./docs/api-reference.md) - Complete technical documentation\r\n\r\n## Community and Support\r\n\r\n**Get Help**\r\n- [Discord Community](https://discord.gg/7Jm7nrhjGn) - Active developer discussions\r\n- [GitHub Issues](https://github.com/rinadelph/Agent-MCP/issues) - Bug reports and features\r\n- [Discussions](https://github.com/rinadelph/Agent-MCP/discussions) - Share your experiences\r\n\r\n**Contributing**\r\nWe welcome contributions! See our [Contributing Guide](CONTRIBUTING.md) for:\r\n- Code style and standards\r\n- Testing requirements\r\n- Pull request process\r\n- Development setup\r\n\r\n## License\r\n\r\n[![License: AGPL v3](https://img.shields.io/badge/License-AGPL_v3-blue.svg)](https://www.gnu.org/licenses/agpl-3.0)\r\n\r\nThis project is licensed under the **GNU Affero General Public License v3.0 (AGPL-3.0)**.\r\n\r\n**What this means:**\r\n- âœ… You can use, modify, and distribute this software\r\n- âœ… You can use it for commercial purposes\r\n- âš ï¸ **Important**: If you run a modified version on a server that users interact with over a network, you **must** provide the source code to those users\r\n- âš ï¸ Any derivative works must also be licensed under AGPL-3.0\r\n- âš ï¸ You must include copyright notices and license information\r\n\r\nSee the [LICENSE](LICENSE) file for complete terms and conditions.\r\n\r\n**Why AGPL?** We chose AGPL to ensure that improvements to Agent-MCP benefit the entire community, even when used in server/SaaS deployments. This prevents proprietary forks that don't contribute back to the ecosystem.\r\n\r\n---\r\n\r\nBuilt by developers who believe AI collaboration should be as sophisticated as human collaboration.",
  "category": "Development",
  "quality_score": 89,
  "archestra_config": {
    "client_config_permutations": {
      "agent_mcp": {
        "command": "uv",
        "args": ["run", "-m", "agent_mcp.cli", "--project-dir", "/path/to/your/project"],
        "env": {}
      }
    },
    "oauth": {
      "provider": null,
      "required": false
    },
    "works_in_archestra": false
  },
  "github_info": {
    "owner": "rinadelph",
    "repo": "Agent-MCP",
    "url": "https://github.com/rinadelph/Agent-MCP",
    "name": "rinadelph__agent-mcp",
    "path": null,
    "stars": 882,
    "contributors": 7,
    "issues": 0,
    "releases": true,
    "ci_cd": true,
    "latest_commit_hash": "89651ba7f84d81ccd403b4ed5c66f8f1dfed735b"
  },
  "programming_language": "TypeScript",
  "framework": null,
  "last_scraped_at": "2025-09-09T13:05:21.208Z",
  "evaluation_model": "gemini-2.5-flash",
  "protocol_features": {
    "implementing_tools": true,
    "implementing_prompts": true,
    "implementing_resources": true,
    "implementing_sampling": true,
    "implementing_roots": true,
    "implementing_logging": false,
    "implementing_stdio": true,
    "implementing_streamable_http": true,
    "implementing_oauth2": false
  },
  "dependencies": [
    {
      "name": "mcp",
      "importance": 10
    },
    {
      "name": "starlette",
      "importance": 10
    },
    {
      "name": "uvicorn",
      "importance": 10
    },
    {
      "name": "openai",
      "importance": 9
    },
    {
      "name": "sqlite-vec",
      "importance": 9
    },
    {
      "name": "httpx",
      "importance": 8
    },
    {
      "name": "jinja2",
      "importance": 8
    },
    {
      "name": "anyio",
      "importance": 7
    },
    {
      "name": "click",
      "importance": 7
    },
    {
      "name": "python-dotenv",
      "importance": 6
    },
    {
      "name": "tabulate",
      "importance": 4
    },
    {
      "name": "pyperclip",
      "importance": 4
    },
    {
      "name": "requests",
      "importance": 4
    }
  ],
  "raw_dependencies": "=== package.json ===\n{\n  \"dependencies\": {\n    \"sqlite-vec\": \"^0.1.7-alpha.2\",\n    \"typescript\": \"^5.9.2\"\n  }\n}\n\n\n=== pyproject.toml ===\n[build-system]\nrequires = [\"setuptools>=42\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"agent-mcp\"\nversion = \"2.5.0\"\ndescription = \"AgentMCP v2.5 - Enhanced multi-agent system with tmux integration and worktree support\"\nauthors = [\n    {name = \"Luis Alejandro Rincon\", email = \"alejandro@rinconnect.com\"},\n]\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nlicense = {text = \"MIT\"}\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\ndependencies = [\n    \"anyio\",\n    \"click\",\n    \"openai\",\n    \"starlette\",\n    \"uvicorn\",\n    \"jinja2\",\n    \"python-dotenv\",\n    \"sqlite-vec\",\n    \"httpx\",\n    \"mcp>=1.8.1\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest\",\n    \"pytest-asyncio\",\n    \"black\",\n    \"isort\",\n]\n\n[tool.setuptools]\npy-modules = []\n\n[tool.setuptools.packages.find]\nwhere = [\".\"]\ninclude = [\"agent_mcp*\"]\n\n[tool.setuptools.package-data]\n\"agent_mcp\" = [\"py.typed\", \"templates/**/*\", \"static/**/*\"]\n\n[tool.rye]\nmanaged = true\ndev-dependencies = [\n    \"pytest>=8.3.2\",\n    \"ruff>=0.5.5\",\n]\n\n[tool.rye.scripts]\n# Default run, assumes server mode\nrun = { cmd = \"uv run -m agent-mcp.cli -- server --port 8080 --project-dir .\" }\nstart = { cmd = \"uv run -m agent-mcp.cli -- server --port 8080 --project-dir .\" }\ncli = { cmd = \"uv run -m agent-mcp.cli --\" }\ntest = { cmd = \"pytest\" }\nlint = { cmd = \"ruff check .\" }\nformat = { cmd = \"ruff format .\" }\nindex = { cmd = \"uv run -m agent-mcp.features.rag.indexing -- --project-dir .\" }\n\n[tool.black]\nline-length = 88\ntarget-version = [\"py310\"]\n\n[tool.isort]\nprofile = \"black\"\nline_length = 88\n\n[tool.ruff]\n# ... existing code ...\n\n[tool.ruff.lint.isort]\nknown-first-party = [\"agent-mcp\"]\n# ... existing code ...\n\n\n=== requirements.txt ===\nanyio\r\nclick\r\nopenai>=1.0.0\r\nstarlette\r\nuvicorn\r\njinja2\r\npython-dotenv\r\nsqlite-vec\r\nhttpx\r\ntabulate\r\npyperclip\r\nmcp\r\nrequests\n\n=== agent-mcp-node/package.json ===\n{\n  \"name\": \"agent-mcp-node\",\n  \"version\": \"4.20.0\",\n  \"description\": \"Agent-MCP TypeScript/Node.js implementation with backwards compatibility\",\n  \"main\": \"build/index.js\",\n  \"type\": \"module\",\n  \"bin\": {\n    \"agent-mcp\": \"build/examples/server/agentMcpServer.js\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"tsx watch src/examples/server/agentMcpServer.ts\",\n    \"start\": \"node build/examples/server/agentMcpServer.js\",\n    \"server\": \"tsx src/examples/server/agentMcpServer.ts\",\n    \"test-client\": \"tsx src/examples/client/streamableHttpWithSseFallbackClient.ts\",\n    \"clean\": \"rm -rf build\",\n    \"postinstall\": \"chmod +x build/examples/server/agentMcpServer.js\",\n    \"prepack\": \"npm run build && chmod +x build/examples/server/agentMcpServer.js\"\n  },\n  \"keywords\": [\n    \"mcp\",\n    \"model-context-protocol\",\n    \"agent\",\n    \"multi-agent\",\n    \"typescript\",\n    \"nodejs\"\n  ],\n  \"author\": \"Luis Alejandro Rincon\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.4.0\",\n    \"@types/better-sqlite3\": \"^7.6.13\",\n    \"@types/cors\": \"^2.8.19\",\n    \"@types/inquirer\": \"^9.0.9\",\n    \"better-sqlite3\": \"^12.2.0\",\n    \"commander\": \"^14.0.0\",\n    \"cors\": \"^2.8.5\",\n    \"dotenv\": \"^17.2.1\",\n    \"express\": \"^4.18.2\",\n    \"glob\": \"^11.0.3\",\n    \"inquirer\": \"^12.9.4\",\n    \"openai\": \"^5.11.0\",\n    \"sqlite-vec\": \"^0.1.7-alpha.2\",\n    \"zod\": \"^3.22.4\"\n  },\n  \"devDependencies\": {\n    \"@types/express\": \"^4.17.21\",\n    \"@types/node\": \"^22.10.0\",\n    \"tsx\": \"^4.7.0\",\n    \"typescript\": \"^5.7.2\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}\n"
}
