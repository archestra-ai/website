{
  "dxt_version": "0.1.0",
  "name": "punkpeye__fastmcp",
  "display_name": "fastmcp",
  "version": "1.0.0",
  "description": "A TypeScript framework for building MCP servers.",
  "author": {
    "name": "punkpeye"
  },
  "server": {
    "type": "node",
    "entry_point": "index.js",
    "mcp_config": {
      "command": "unknown",
      "args": [],
      "env": {}
    }
  },
  "tools": [],
  "prompts": [],
  "keywords": [],
  "user_config": {},
  "readme": "# FastMCP\n\nA TypeScript framework for building [MCP](https://glama.ai/mcp) servers capable of handling client sessions.\n\n> [!NOTE]\n>\n> For a Python implementation, see [FastMCP](https://github.com/jlowin/fastmcp).\n\n## Features\n\n- Simple Tool, Resource, Prompt definition\n- [Authentication](#authentication)\n- [Passing headers through context](#passing-headers-through-context)\n- [Sessions](#sessions)\n- [Image content](#returning-an-image)\n- [Audio content](#returning-an-audio)\n- [Embedded](#embedded-resources)\n- [Logging](#logging)\n- [Error handling](#errors)\n- [HTTP Streaming](#http-streaming) (with SSE compatibility)\n- [Stateless mode](#stateless-mode) for serverless deployments\n- CORS (enabled by default)\n- [Progress notifications](#progress)\n- [Streaming output](#streaming-output)\n- [Typed server events](#typed-server-events)\n- [Prompt argument auto-completion](#prompt-argument-auto-completion)\n- [Sampling](#requestsampling)\n- [Configurable ping behavior](#configurable-ping-behavior)\n- [Health-check endpoint](#health-check-endpoint)\n- [Roots](#roots-management)\n- CLI for [testing](#test-with-mcp-cli) and [debugging](#inspect-with-mcp-inspector)\n\n## When to use FastMCP over the official SDK?\n\nFastMCP is built on top of the official SDK.\n\nThe official SDK provides foundational blocks for building MCPs, but leaves many implementation details to you:\n\n- [Initiating and configuring](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L664-L744) all the server components\n- [Handling of connections](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L760-L850)\n- [Handling of tools](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L1303-L1498)\n- [Handling of responses](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L989-L1060)\n- [Handling of resources](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L1151-L1242)\n- Adding [prompts](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L760-L850), [resources](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L960-L962), [resource templates](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L964-L987)\n- Embedding [resources](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L1569-L1643), [image](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L51-L111) and [audio](https://github.com/punkpeye/fastmcp/blob/06c2af7a3d7e3d8c638deac1964ce269ce8e518b/src/FastMCP.ts#L113-L173) content blocks\n\nFastMCP eliminates this complexity by providing an opinionated framework that:\n\n- Handles all the boilerplate automatically\n- Provides simple, intuitive APIs for common tasks\n- Includes built-in best practices and error handling\n- Lets you focus on your MCP's core functionality\n\n**When to choose FastMCP:** You want to build MCP servers quickly without dealing with low-level implementation details.\n\n**When to use the official SDK:** You need maximum control or have specific architectural requirements. In this case, we encourage referencing FastMCP's implementation to avoid common pitfalls.\n\n## Installation\n\n```bash\nnpm install fastmcp\n```\n\n## Quickstart\n\n> [!NOTE]\n>\n> There are many real-world examples of using FastMCP in the wild. See the [Showcase](#showcase) for examples.\n\n```ts\nimport { FastMCP } from \"fastmcp\";\nimport { z } from \"zod\"; // Or any validation library that supports Standard Schema\n\nconst server = new FastMCP({\n  name: \"My Server\",\n  version: \"1.0.0\",\n});\n\nserver.addTool({\n  name: \"add\",\n  description: \"Add two numbers\",\n  parameters: z.object({\n    a: z.number(),\n    b: z.number(),\n  }),\n  execute: async (args) => {\n    return String(args.a + args.b);\n  },\n});\n\nserver.start({\n  transportType: \"stdio\",\n});\n```\n\n_That's it!_ You have a working MCP server.\n\nYou can test the server in terminal with:\n\n```bash\ngit clone https://github.com/punkpeye/fastmcp.git\ncd fastmcp\n\npnpm install\npnpm build\n\n# Test the addition server example using CLI:\nnpx fastmcp dev src/examples/addition.ts\n# Test the addition server example using MCP Inspector:\nnpx fastmcp inspect src/examples/addition.ts\n```\n\nIf you are looking for a boilerplate repository to build your own MCP server, check out [fastmcp-boilerplate](https://github.com/punkpeye/fastmcp-boilerplate).\n\n### Remote Server Options\n\nFastMCP supports multiple transport options for remote communication, allowing an MCP hosted on a remote machine to be accessed over the network.\n\n#### HTTP Streaming\n\n[HTTP streaming](https://www.cloudflare.com/learning/video/what-is-http-live-streaming/) provides a more efficient alternative to SSE in environments that support it, with potentially better performance for larger payloads.\n\nYou can run the server with HTTP streaming support:\n\n```ts\nserver.start({\n  transportType: \"httpStream\",\n  httpStream: {\n    port: 8080,\n  },\n});\n```\n\nThis will start the server and listen for HTTP streaming connections on `http://localhost:8080/mcp`.\n\n> **Note:** You can also customize the endpoint path using the `httpStream.endpoint` option (default is `/mcp`).\n\nYou can connect to these servers using the appropriate client transport.\n\nFor HTTP streaming connections:\n\n```ts\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\n\nconst client = new Client(\n  {\n    name: \"example-client\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {},\n  },\n);\n\nconst transport = new StreamableHTTPClientTransport(\n  new URL(`http://localhost:8080/mcp`),\n);\n\nawait client.connect(transport);\n```\n\nFor SSE connections:\n\n```ts\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\n\nconst client = new Client(\n  {\n    name: \"example-client\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {},\n  },\n);\n\nconst transport = new SSEClientTransport(new URL(`http://localhost:8080/sse`));\n\nawait client.connect(transport);\n```\n\n#### Stateless Mode\n\nFastMCP supports stateless operation for HTTP streaming, where each request is handled independently without maintaining persistent sessions. This is ideal for serverless environments, load-balanced deployments, or when session state isn't required.\n\nIn stateless mode:\n\n- No sessions are tracked on the server\n- Each request creates a temporary session that's discarded after the response\n- Reduced memory usage and better scalability\n- Perfect for stateless deployment environments\n\nYou can enable stateless mode by adding the `stateless: true` option:\n\n```ts\nserver.start({\n  transportType: \"httpStream\",\n  httpStream: {\n    port: 8080,\n    stateless: true,\n  },\n});\n```\n\n> **Note:** Stateless mode is only available with HTTP streaming transport. Features that depend on persistent sessions (like session-specific state) will not be available in stateless mode.\n\nYou can also enable stateless mode using CLI arguments or environment variables:\n\n```bash\n# Via CLI argument\nnpx fastmcp dev src/server.ts --transport http-stream --port 8080 --stateless true\n\n# Via environment variable\nFASTMCP_STATELESS=true npx fastmcp dev src/server.ts\n```\n\nThe `/ready` health check endpoint will indicate when the server is running in stateless mode:\n\n```json\n{\n  \"mode\": \"stateless\",\n  \"ready\": 1,\n  \"status\": \"ready\",\n  \"total\": 1\n}\n```\n\n## Core Concepts\n\n### Tools\n\n[Tools](https://modelcontextprotocol.io/docs/concepts/tools) in MCP allow servers to expose executable functions that can be invoked by clients and used by LLMs to perform actions.\n\nFastMCP uses the [Standard Schema](https://standardschema.dev) specification for defining tool parameters. This allows you to use your preferred schema validation library (like Zod, ArkType, or Valibot) as long as it implements the spec.\n\n**Zod Example:**\n\n```typescript\nimport { z } from \"zod\";\n\nserver.addTool({\n  name: \"fetch-zod\",\n  description: \"Fetch the content of a url (using Zod)\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args) => {\n    return await fetchWebpageContent(args.url);\n  },\n});\n```\n\n**ArkType Example:**\n\n```typescript\nimport { type } from \"arktype\";\n\nserver.addTool({\n  name: \"fetch-arktype\",\n  description: \"Fetch the content of a url (using ArkType)\",\n  parameters: type({\n    url: \"string\",\n  }),\n  execute: async (args) => {\n    return await fetchWebpageContent(args.url);\n  },\n});\n```\n\n**Valibot Example:**\n\nValibot requires the peer dependency @valibot/to-json-schema.\n\n```typescript\nimport * as v from \"valibot\";\n\nserver.addTool({\n  name: \"fetch-valibot\",\n  description: \"Fetch the content of a url (using Valibot)\",\n  parameters: v.object({\n    url: v.string(),\n  }),\n  execute: async (args) => {\n    return await fetchWebpageContent(args.url);\n  },\n});\n```\n\n#### Tools Without Parameters\n\nWhen creating tools that don't require parameters, you have two options:\n\n1. Omit the parameters property entirely:\n\n   ```typescript\n   server.addTool({\n     name: \"sayHello\",\n     description: \"Say hello\",\n     // No parameters property\n     execute: async () => {\n       return \"Hello, world!\";\n     },\n   });\n   ```\n\n2. Explicitly define empty parameters:\n\n   ```typescript\n   import { z } from \"zod\";\n\n   server.addTool({\n     name: \"sayHello\",\n     description: \"Say hello\",\n     parameters: z.object({}), // Empty object\n     execute: async () => {\n       return \"Hello, world!\";\n     },\n   });\n   ```\n\n> [!NOTE]\n>\n> Both approaches are fully compatible with all MCP clients, including Cursor. FastMCP automatically generates the proper schema in both cases.\n\n#### Tool Authorization\n\nYou can control which tools are available to authenticated users by adding an optional `canAccess` function to a tool's definition. This function receives the authentication context and should return `true` if the user is allowed to access the tool.\n\n```typescript\nserver.addTool({\n  name: \"admin-tool\",\n  description: \"An admin-only tool\",\n  canAccess: (auth) => auth?.role === \"admin\",\n  execute: async () => \"Welcome, admin!\",\n});\n```\n\n#### Returning a string\n\n`execute` can return a string:\n\n```js\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args) => {\n    return \"Hello, world!\";\n  },\n});\n```\n\nThe latter is equivalent to:\n\n```js\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args) => {\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: \"Hello, world!\",\n        },\n      ],\n    };\n  },\n});\n```\n\n#### Returning a list\n\nIf you want to return a list of messages, you can return an object with a `content` property:\n\n```js\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args) => {\n    return {\n      content: [\n        { type: \"text\", text: \"First message\" },\n        { type: \"text\", text: \"Second message\" },\n      ],\n    };\n  },\n});\n```\n\n#### Returning an image\n\nUse the `imageContent` to create a content object for an image:\n\n```js\nimport { imageContent } from \"fastmcp\";\n\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args) => {\n    return imageContent({\n      url: \"https://example.com/image.png\",\n    });\n\n    // or...\n    // return imageContent({\n    //   path: \"/path/to/image.png\",\n    // });\n\n    // or...\n    // return imageContent({\n    //   buffer: Buffer.from(\"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\", \"base64\"),\n    // });\n\n    // or...\n    // return {\n    //   content: [\n    //     await imageContent(...)\n    //   ],\n    // };\n  },\n});\n```\n\nThe `imageContent` function takes the following options:\n\n- `url`: The URL of the image.\n- `path`: The path to the image file.\n- `buffer`: The image data as a buffer.\n\nOnly one of `url`, `path`, or `buffer` must be specified.\n\nThe above example is equivalent to:\n\n```js\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args) => {\n    return {\n      content: [\n        {\n          type: \"image\",\n          data: \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\",\n          mimeType: \"image/png\",\n        },\n      ],\n    };\n  },\n});\n```\n\n#### Configurable Ping Behavior\n\nFastMCP includes a configurable ping mechanism to maintain connection health. The ping behavior can be customized through server options:\n\n```ts\nconst server = new FastMCP({\n  name: \"My Server\",\n  version: \"1.0.0\",\n  ping: {\n    // Explicitly enable or disable pings (defaults vary by transport)\n    enabled: true,\n    // Configure ping interval in milliseconds (default: 5000ms)\n    intervalMs: 10000,\n    // Set log level for ping-related messages (default: 'debug')\n    logLevel: \"debug\",\n  },\n});\n```\n\nBy default, ping behavior is optimized for each transport type:\n\n- Enabled for SSE and HTTP streaming connections (which benefit from keep-alive)\n- Disabled for `stdio` connections (where pings are typically unnecessary)\n\nThis configurable approach helps reduce log verbosity and optimize performance for different usage scenarios.\n\n### Health-check Endpoint\n\nWhen you run FastMCP with the `httpStream` transport you can optionally expose a\nsimple HTTP endpoint that returns a plain-text response useful for load-balancer\nor container orchestration liveness checks.\n\nEnable (or customise) the endpoint via the `health` key in the server options:\n\n```ts\nconst server = new FastMCP({\n  name: \"My Server\",\n  version: \"1.0.0\",\n  health: {\n    // Enable / disable (default: true)\n    enabled: true,\n    // Body returned by the endpoint (default: 'ok')\n    message: \"healthy\",\n    // Path that should respond (default: '/health')\n    path: \"/healthz\",\n    // HTTP status code to return (default: 200)\n    status: 200,\n  },\n});\n\nawait server.start({\n  transportType: \"httpStream\",\n  httpStream: { port: 8080 },\n});\n```\n\nNow a request to `http://localhost:8080/healthz` will return:\n\n```\nHTTP/1.1 200 OK\ncontent-type: text/plain\n\nhealthy\n```\n\nThe endpoint is ignored when the server is started with the `stdio` transport.\n\n#### Roots Management\n\nFastMCP supports [Roots](https://modelcontextprotocol.io/docs/concepts/roots) - Feature that allows clients to provide a set of filesystem-like root locations that can be listed and dynamically updated. The Roots feature can be configured or disabled in server options:\n\n```ts\nconst server = new FastMCP({\n  name: \"My Server\",\n  version: \"1.0.0\",\n  roots: {\n    // Set to false to explicitly disable roots support\n    enabled: false,\n    // By default, roots support is enabled (true)\n  },\n});\n```\n\nThis provides the following benefits:\n\n- Better compatibility with different clients that may not support Roots\n- Reduced error logs when connecting to clients that don't implement roots capability\n- More explicit control over MCP server capabilities\n- Graceful degradation when roots functionality isn't available\n\nYou can listen for root changes in your server:\n\n```ts\nserver.on(\"connect\", (event) => {\n  const session = event.session;\n\n  // Access the current roots\n  console.log(\"Initial roots:\", session.roots);\n\n  // Listen for changes to the roots\n  session.on(\"rootsChanged\", (event) => {\n    console.log(\"Roots changed:\", event.roots);\n  });\n});\n```\n\nWhen a client doesn't support roots or when roots functionality is explicitly disabled, these operations will gracefully handle the situation without throwing errors.\n\n### Returning an audio\n\nUse the `audioContent` to create a content object for an audio:\n\n```js\nimport { audioContent } from \"fastmcp\";\n\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args) => {\n    return audioContent({\n      url: \"https://example.com/audio.mp3\",\n    });\n\n    // or...\n    // return audioContent({\n    //   path: \"/path/to/audio.mp3\",\n    // });\n\n    // or...\n    // return audioContent({\n    //   buffer: Buffer.from(\"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\", \"base64\"),\n    // });\n\n    // or...\n    // return {\n    //   content: [\n    //     await audioContent(...)\n    //   ],\n    // };\n  },\n});\n```\n\nThe `audioContent` function takes the following options:\n\n- `url`: The URL of the audio.\n- `path`: The path to the audio file.\n- `buffer`: The audio data as a buffer.\n\nOnly one of `url`, `path`, or `buffer` must be specified.\n\nThe above example is equivalent to:\n\n```js\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args) => {\n    return {\n      content: [\n        {\n          type: \"audio\",\n          data: \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\",\n          mimeType: \"audio/mpeg\",\n        },\n      ],\n    };\n  },\n});\n```\n\n#### Return combination type\n\nYou can combine various types in this way and send them back to AI\n\n```js\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args) => {\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: \"Hello, world!\",\n        },\n        {\n          type: \"image\",\n          data: \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\",\n          mimeType: \"image/png\",\n        },\n        {\n          type: \"audio\",\n          data: \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\",\n          mimeType: \"audio/mpeg\",\n        },\n      ],\n    };\n  },\n\n  // or...\n  // execute: async (args) => {\n  //   const imgContent = await imageContent({\n  //     url: \"https://example.com/image.png\",\n  //   });\n  //   const audContent = await audioContent({\n  //     url: \"https://example.com/audio.mp3\",\n  //   });\n  //   return {\n  //     content: [\n  //       {\n  //         type: \"text\",\n  //         text: \"Hello, world!\",\n  //       },\n  //       imgContent,\n  //       audContent,\n  //     ],\n  //   };\n  // },\n});\n```\n\n#### Logging\n\nTools can log messages to the client using the `log` object in the context object:\n\n```js\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args, { log }) => {\n    log.info(\"Downloading file...\", {\n      url,\n    });\n\n    // ...\n\n    log.info(\"Downloaded file\");\n\n    return \"done\";\n  },\n});\n```\n\nThe `log` object has the following methods:\n\n- `debug(message: string, data?: SerializableValue)`\n- `error(message: string, data?: SerializableValue)`\n- `info(message: string, data?: SerializableValue)`\n- `warn(message: string, data?: SerializableValue)`\n\n#### Errors\n\nThe errors that are meant to be shown to the user should be thrown as `UserError` instances:\n\n```js\nimport { UserError } from \"fastmcp\";\n\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args) => {\n    if (args.url.startsWith(\"https://example.com\")) {\n      throw new UserError(\"This URL is not allowed\");\n    }\n\n    return \"done\";\n  },\n});\n```\n\n#### Progress\n\nTools can report progress by calling `reportProgress` in the context object:\n\n```js\nserver.addTool({\n  name: \"download\",\n  description: \"Download a file\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  execute: async (args, { reportProgress }) => {\n    await reportProgress({\n      progress: 0,\n      total: 100,\n    });\n\n    // ...\n\n    await reportProgress({\n      progress: 100,\n      total: 100,\n    });\n\n    return \"done\";\n  },\n});\n```\n\n#### Streaming Output\n\nFastMCP supports streaming partial results from tools while they're still executing, enabling responsive UIs and real-time feedback. This is particularly useful for:\n\n- Long-running operations that generate content incrementally\n- Progressive generation of text, images, or other media\n- Operations where users benefit from seeing immediate partial results\n\nTo enable streaming for a tool, add the `streamingHint` annotation and use the `streamContent` method:\n\n````js\nserver.addTool({\n  name: \"generateText\",\n  description: \"Generate text incrementally\",\n  parameters: z.object({\n    prompt: z.string(),\n  }),\n  annotations: {\n    streamingHint: true, // Signals this tool uses streaming\n    readOnlyHint: true,\n  },\n  execute: async (args, { streamContent }) => {\n    // Send initial content immediately\n    await streamContent({ type: \"text\", text: \"Starting generation...\\n\" });\n\n    // Simulate incremental content generation\n    const words = \"The quick brown fox jumps over the lazy dog.\".split(\" \");\n    for (const word of words) {\n      await streamContent({ type: \"text\", text: word + \" \" });\n      await new Promise((resolve) => setTimeout(resolve, 300)); // Simulate delay\n    }\n\n    // When using streamContent, you can:\n    // 1. Return void (if all content was streamed)\n    // 2. Return a final result (which will be appended to streamed content)\n\n    // Option 1: All content was streamed, so return void\n    return;\n\n    // Option 2: Return final content that will be appended\n    // return \"Generation complete!\";\n  },\n});\n\nStreaming works with all content types (text, image, audio) and can be combined with progress reporting:\n\n```js\nserver.addTool({\n  name: \"processData\",\n  description: \"Process data with streaming updates\",\n  parameters: z.object({\n    datasetSize: z.number(),\n  }),\n  annotations: {\n    streamingHint: true,\n  },\n  execute: async (args, { streamContent, reportProgress }) => {\n    const total = args.datasetSize;\n\n    for (let i = 0; i < total; i++) {\n      // Report numeric progress\n      await reportProgress({ progress: i, total });\n\n      // Stream intermediate results\n      if (i % 10 === 0) {\n        await streamContent({\n          type: \"text\",\n          text: `Processed ${i} of ${total} items...\\n`,\n        });\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 50));\n    }\n\n    return \"Processing complete!\";\n  },\n});\n````\n\n#### Tool Annotations\n\nAs of the MCP Specification (2025-03-26), tools can include annotations that provide richer context and control by adding metadata about a tool's behavior:\n\n```typescript\nserver.addTool({\n  name: \"fetch-content\",\n  description: \"Fetch content from a URL\",\n  parameters: z.object({\n    url: z.string(),\n  }),\n  annotations: {\n    title: \"Web Content Fetcher\", // Human-readable title for UI display\n    readOnlyHint: true, // Tool doesn't modify its environment\n    openWorldHint: true, // Tool interacts with external entities\n  },\n  execute: async (args) => {\n    return await fetchWebpageContent(args.url);\n  },\n});\n```\n\nThe available annotations are:\n\n| Annotation        | Type    | Default | Description                                                                                                                          |\n| :---------------- | :------ | :------ | :----------------------------------------------------------------------------------------------------------------------------------- |\n| `title`           | string  | -       | A human-readable title for the tool, useful for UI display                                                                           |\n| `readOnlyHint`    | boolean | `false` | If true, indicates the tool does not modify its environment                                                                          |\n| `destructiveHint` | boolean | `true`  | If true, the tool may perform destructive updates (only meaningful when `readOnlyHint` is false)                                     |\n| `idempotentHint`  | boolean | `false` | If true, calling the tool repeatedly with the same arguments has no additional effect (only meaningful when `readOnlyHint` is false) |\n| `openWorldHint`   | boolean | `true`  | If true, the tool may interact with an \"open world\" of external entities                                                             |\n\nThese annotations help clients and LLMs better understand how to use the tools and what to expect when calling them.\n\n### Resources\n\n[Resources](https://modelcontextprotocol.io/docs/concepts/resources) represent any kind of data that an MCP server wants to make available to clients. This can include:\n\n- File contents\n- Screenshots and images\n- Log files\n- And more\n\nEach resource is identified by a unique URI and can contain either text or binary data.\n\n```ts\nserver.addResource({\n  uri: \"file:///logs/app.log\",\n  name: \"Application Logs\",\n  mimeType: \"text/plain\",\n  async load() {\n    return {\n      text: await readLogFile(),\n    };\n  },\n});\n```\n\n> [!NOTE]\n>\n> `load` can return multiple resources. This could be used, for example, to return a list of files inside a directory when the directory is read.\n>\n> ```ts\n> async load() {\n>   return [\n>     {\n>       text: \"First file content\",\n>     },\n>     {\n>       text: \"Second file content\",\n>     },\n>   ];\n> }\n> ```\n\nYou can also return binary contents in `load`:\n\n```ts\nasync load() {\n  return {\n    blob: 'base64-encoded-data'\n  };\n}\n```\n\n### Resource templates\n\nYou can also define resource templates:\n\n```ts\nserver.addResourceTemplate({\n  uriTemplate: \"file:///logs/{name}.log\",\n  name: \"Application Logs\",\n  mimeType: \"text/plain\",\n  arguments: [\n    {\n      name: \"name\",\n      description: \"Name of the log\",\n      required: true,\n    },\n  ],\n  async load({ name }) {\n    return {\n      text: `Example log content for ${name}`,\n    };\n  },\n});\n```\n\n#### Resource template argument auto-completion\n\nProvide `complete` functions for resource template arguments to enable automatic completion:\n\n```ts\nserver.addResourceTemplate({\n  uriTemplate: \"file:///logs/{name}.log\",\n  name: \"Application Logs\",\n  mimeType: \"text/plain\",\n  arguments: [\n    {\n      name: \"name\",\n      description: \"Name of the log\",\n      required: true,\n      complete: async (value) => {\n        if (value === \"Example\") {\n          return {\n            values: [\"Example Log\"],\n          };\n        }\n\n        return {\n          values: [],\n        };\n      },\n    },\n  ],\n  async load({ name }) {\n    return {\n      text: `Example log content for ${name}`,\n    };\n  },\n});\n```\n\n### Embedded Resources\n\nFastMCP provides a convenient `embedded()` method that simplifies including resources in tool responses. This feature reduces code duplication and makes it easier to reference resources from within tools.\n\n#### Basic Usage\n\n```js\nserver.addTool({\n  name: \"get_user_data\",\n  description: \"Retrieve user information\",\n  parameters: z.object({\n    userId: z.string(),\n  }),\n  execute: async (args) => {\n    return {\n      content: [\n        {\n          type: \"resource\",\n          resource: await server.embedded(`user://profile/${args.userId}`),\n        },\n      ],\n    };\n  },\n});\n```\n\n#### Working with Resource Templates\n\nThe `embedded()` method works seamlessly with resource templates:\n\n```js\n// Define a resource template\nserver.addResourceTemplate({\n  uriTemplate: \"docs://project/{section}\",\n  name: \"Project Documentation\",\n  mimeType: \"text/markdown\",\n  arguments: [\n    {\n      name: \"section\",\n      required: true,\n    },\n  ],\n  async load(args) {\n    const docs = {\n      \"getting-started\": \"# Getting Started\\n\\nWelcome to our project!\",\n      \"api-reference\": \"# API Reference\\n\\nAuthentication is required.\",\n    };\n    return {\n      text: docs[args.section] || \"Documentation not found\",\n    };\n  },\n});\n\n// Use embedded resources in a tool\nserver.addTool({\n  name: \"get_documentation\",\n  description: \"Retrieve project documentation\",\n  parameters: z.object({\n    section: z.enum([\"getting-started\", \"api-reference\"]),\n  }),\n  execute: async (args) => {\n    return {\n      content: [\n        {\n          type: \"resource\",\n          resource: await server.embedded(`docs://project/${args.section}`),\n        },\n      ],\n    };\n  },\n});\n```\n\n#### Working with Direct Resources\n\nIt also works with directly defined resources:\n\n```js\n// Define a direct resource\nserver.addResource({\n  uri: \"system://status\",\n  name: \"System Status\",\n  mimeType: \"text/plain\",\n  async load() {\n    return {\n      text: \"System operational\",\n    };\n  },\n});\n\n// Use in a tool\nserver.addTool({\n  name: \"get_system_status\",\n  description: \"Get current system status\",\n  parameters: z.object({}),\n  execute: async () => {\n    return {\n      content: [\n        {\n          type: \"resource\",\n          resource: await server.embedded(\"system://status\"),\n        },\n      ],\n    };\n  },\n});\n```\n\n### Prompts\n\n[Prompts](https://modelcontextprotocol.io/docs/concepts/prompts) enable servers to define reusable prompt templates and workflows that clients can easily surface to users and LLMs. They provide a powerful way to standardize and share common LLM interactions.\n\n```ts\nserver.addPrompt({\n  name: \"git-commit\",\n  description: \"Generate a Git commit message\",\n  arguments: [\n    {\n      name: \"changes\",\n      description: \"Git diff or description of changes\",\n      required: true,\n    },\n  ],\n  load: async (args) => {\n    return `Generate a concise but descriptive commit message for these changes:\\n\\n${args.changes}`;\n  },\n});\n```\n\n#### Prompt argument auto-completion\n\nPrompts can provide auto-completion for their arguments:\n\n```js\nserver.addPrompt({\n  name: \"countryPoem\",\n  description: \"Writes a poem about a country\",\n  load: async ({ name }) => {\n    return `Hello, ${name}!`;\n  },\n  arguments: [\n    {\n      name: \"name\",\n      description: \"Name of the country\",\n      required: true,\n      complete: async (value) => {\n        if (value === \"Germ\") {\n          return {\n            values: [\"Germany\"],\n          };\n        }\n\n        return {\n          values: [],\n        };\n      },\n    },\n  ],\n});\n```\n\n#### Prompt argument auto-completion using `enum`\n\nIf you provide an `enum` array for an argument, the server will automatically provide completions for the argument.\n\n```js\nserver.addPrompt({\n  name: \"countryPoem\",\n  description: \"Writes a poem about a country\",\n  load: async ({ name }) => {\n    return `Hello, ${name}!`;\n  },\n  arguments: [\n    {\n      name: \"name\",\n      description: \"Name of the country\",\n      required: true,\n      enum: [\"Germany\", \"France\", \"Italy\"],\n    },\n  ],\n});\n```\n\n### Authentication\n\nFastMCP supports session-based authentication, allowing you to secure your server and control access to its features.\n\n> [!NOTE]\n> For more granular control over which tools are available to authenticated users, see the [Tool Authorization](#tool-authorization) section.\n\nTo enable authentication, provide an `authenticate` function in the server options. This function receives the incoming HTTP request and should return a promise that resolves with the authentication context.\n\nIf authentication fails, the function should throw a `Response` object, which will be sent to the client.\n\n```ts\nconst server = new FastMCP({\n  name: \"My Server\",\n  version: \"1.0.0\",\n  authenticate: (request) => {\n    const apiKey = request.headers[\"x-api-key\"];\n\n    if (apiKey !== \"123\") {\n      throw new Response(null, {\n        status: 401,\n        statusText: \"Unauthorized\",\n      });\n    }\n\n    // Whatever you return here will be accessible in the `context.session` object.\n    return {\n      id: 1,\n    };\n  },\n});\n```\n\nNow you can access the authenticated session data in your tools:\n\n```ts\nserver.addTool({\n  name: \"sayHello\",\n  execute: async (args, { session }) => {\n    return `Hello, ${session.id}!`;\n  },\n});\n```\n\n#### Tool Authorization\n\nYou can control which tools are available to authenticated users by adding an optional `canAccess` function to a tool's definition. This function receives the authentication context and should return `true` if the user is allowed to access the tool.\n\nIf `canAccess` is not provided, the tool is accessible to all authenticated users by default. If no authentication is configured on the server, all tools are available to all clients.\n\n**Example:**\n\n```typescript\nconst server = new FastMCP<{ role: \"admin\" | \"user\" }>({\n  authenticate: async (request) => {\n    const role = request.headers[\"x-role\"] as string;\n    return { role: role === \"admin\" ? \"admin\" : \"user\" };\n  },\n  name: \"My Server\",\n  version: \"1.0.0\",\n});\n\nserver.addTool({\n  name: \"admin-dashboard\",\n  description: \"An admin-only tool\",\n  // Only users with the 'admin' role can see and execute this tool\n  canAccess: (auth) => auth?.role === \"admin\",\n  execute: async () => {\n    return \"Welcome to the admin dashboard!\";\n  },\n});\n\nserver.addTool({\n  name: \"public-info\",\n  description: \"A tool available to everyone\",\n  execute: async () => {\n    return \"This is public information.\";\n  },\n});\n```\n\nIn this example, only clients authenticating with the `admin` role will be able to list or call the `admin-dashboard` tool. The `public-info` tool will be available to all authenticated users.\n\n#### OAuth Support\n\nFastMCP includes built-in support for OAuth discovery endpoints, supporting both **MCP Specification 2025-03-26** and **MCP Specification 2025-06-18** for OAuth integration. This makes it easy to integrate with OAuth authorization flows by providing standard discovery endpoints that comply with RFC 8414 (OAuth 2.0 Authorization Server Metadata) and RFC 9470 (OAuth 2.0 Protected Resource Metadata):\n\n```ts\nimport { FastMCP } from \"fastmcp\";\nimport { buildGetJwks } from \"get-jwks\";\nimport fastJwt from \"fast-jwt\";\n\nconst server = new FastMCP({\n  name: \"My Server\",\n  version: \"1.0.0\",\n  oauth: {\n    enabled: true,\n    authorizationServer: {\n      issuer: \"https://auth.example.com\",\n      authorizationEndpoint: \"https://auth.example.com/oauth/authorize\",\n      tokenEndpoint: \"https://auth.example.com/oauth/token\",\n      jwksUri: \"https://auth.example.com/.well-known/jwks.json\",\n      responseTypesSupported: [\"code\"],\n    },\n    protectedResource: {\n      resource: \"mcp://my-server\",\n      authorizationServers: [\"https://auth.example.com\"],\n    },\n  },\n  authenticate: async (request) => {\n    const authHeader = request.headers.authorization;\n\n    if (!authHeader?.startsWith(\"Bearer \")) {\n      throw new Response(null, {\n        status: 401,\n        statusText: \"Missing or invalid authorization header\",\n      });\n    }\n\n    const token = authHeader.slice(7); // Remove 'Bearer ' prefix\n\n    // Validate OAuth JWT access token using OpenID Connect discovery\n    try {\n      // TODO: Cache the discovery document to avoid repeated requests\n      // Discover OAuth/OpenID configuration from well-known endpoint\n      const discoveryUrl =\n        \"https://auth.example.com/.well-known/openid-configuration\";\n      // Alternative: Use OAuth authorization server metadata endpoint\n      // const discoveryUrl = 'https://auth.example.com/.well-known/oauth-authorization-server';\n\n      const discoveryResponse = await fetch(discoveryUrl);\n      if (!discoveryResponse.ok) {\n        throw new Error(\"Failed to fetch OAuth discovery document\");\n      }\n\n      const config = await discoveryResponse.json();\n      const jwksUri = config.jwks_uri;\n      const issuer = config.issuer;\n\n      // Create JWKS client for token verification using discovered endpoint\n      const getJwks = buildGetJwks({\n        jwksUrl: jwksUri,\n        cache: true,\n        rateLimit: true,\n      });\n\n      // Create JWT verifier with JWKS and discovered issuer\n      const verify = fastJwt.createVerifier({\n        key: async (token) => {\n          const { header } = fastJwt.decode(token, { complete: true });\n          const jwk = await getJwks.getJwk({\n            kid: header.kid,\n            alg: header.alg,\n          });\n          return jwk;\n        },\n        algorithms: [\"RS256\", \"ES256\"],\n        issuer: issuer,\n        audience: \"mcp://my-server\",\n      });\n\n      // Verify the JWT token\n      const payload = await verify(token);\n\n      return {\n        userId: payload.sub,\n        scope: payload.scope,\n        email: payload.email,\n        // Include other claims as needed\n      };\n    } catch (error) {\n      throw new Response(null, {\n        status: 401,\n        statusText: \"Invalid OAuth token\",\n      });\n    }\n  },\n});\n```\n\nThis configuration automatically exposes OAuth discovery endpoints:\n\n- `/.well-known/oauth-authorization-server` - Authorization server metadata (RFC 8414)\n- `/.well-known/oauth-protected-resource` - Protected resource metadata (RFC 9470)\n\nFor JWT token validation, you can use libraries like [`get-jwks`](https://github.com/nearform/get-jwks) and [`@fastify/jwt`](https://github.com/fastify/fastify-jwt) for OAuth JWT tokens.\n\n#### Passing Headers Through Context\n\nIf you are exposing your MCP server via HTTP, you may wish to allow clients to supply sensitive keys via headers, which can then be passed along to APIs that your tools interact with, allowing each client to supply their own API keys. This can be done by capturing the HTTP headers in the `authenticate` section and storing them in the session to be referenced by the tools later.\n\n```ts\nimport { FastMCP } from \"fastmcp\";\nimport { IncomingHttpHeaders } from \"http\";\n\n// Define the session data type\ninterface SessionData {\n  headers: IncomingHttpHeaders;\n  [key: string]: unknown; // Add index signature to satisfy Record<string, unknown>\n}\n\n// Create a server instance\nconst server = new FastMCP({\n  name: \"My Server\",\n  version: \"1.0.0\",\n  authenticate: async (request: any): Promise<SessionData> => {\n    // Authentication logic\n    return {\n      headers: request.headers,\n    };\n  },\n});\n\n// Tool to display HTTP headers\nserver.addTool({\n  name: \"headerTool\",\n  description: \"Reads HTTP headers from the request\",\n  execute: async (args: any, context: any) => {\n    const session = context.session as SessionData;\n    const headers = session?.headers ?? {};\n\n    const getHeaderString = (header: string | string[] | undefined) =>\n      Array.isArray(header) ? header.join(\", \") : (header ?? \"N/A\");\n\n    const userAgent = getHeaderString(headers[\"user-agent\"]);\n    const authorization = getHeaderString(headers[\"authorization\"]);\n    return `User-Agent: ${userAgent}\\nAuthorization: ${authorization}\\nAll Headers: ${JSON.stringify(headers, null, 2)}`;\n  },\n});\n\n// Start the server\nserver.start({\n  transportType: \"httpStream\",\n  httpStream: {\n    port: 8080,\n  },\n});\n```\n\nA client that would connect to this may look something like this:\n\n```ts\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\n\nconst transport = new StreamableHTTPClientTransport(\n  new URL(`http://localhost:8080/mcp`),\n  {\n    requestInit: {\n      headers: {\n        Authorization: \"Test 123\",\n      },\n    },\n  },\n);\n\nconst client = new Client({\n  name: \"example-client\",\n  version: \"1.0.0\",\n});\n\n(async () => {\n  await client.connect(transport);\n\n  // Call a tool\n  const result = await client.callTool({\n    name: \"headerTool\",\n    arguments: {\n      arg1: \"value\",\n    },\n  });\n\n  console.log(\"Tool result:\", result);\n})().catch(console.error);\n```\n\nWhat would show up in the console after the client runs is something like this:\n\n```\nTool result: {\n  content: [\n    {\n      type: 'text',\n      text: 'User-Agent: node\\n' +\n        'Authorization: Test 123\\n' +\n        'All Headers: {\\n' +\n        '  \"host\": \"localhost:8080\",\\n' +\n        '  \"connection\": \"keep-alive\",\\n' +\n        '  \"authorization\": \"Test 123\",\\n' +\n        '  \"content-type\": \"application/json\",\\n' +\n        '  \"accept\": \"application/json, text/event-stream\",\\n' +\n        '  \"accept-language\": \"*\",\\n' +\n        '  \"sec-fetch-mode\": \"cors\",\\n' +\n        '  \"user-agent\": \"node\",\\n' +\n        '  \"accept-encoding\": \"gzip, deflate\",\\n' +\n        '  \"content-length\": \"163\"\\n' +\n        '}'\n    }\n  ]\n}\n```\n\n### Providing Instructions\n\nYou can provide instructions to the server using the `instructions` option:\n\n```ts\nconst server = new FastMCP({\n  name: \"My Server\",\n  version: \"1.0.0\",\n  instructions:\n    'Instructions describing how to use the server and its features.\\n\\nThis can be used by clients to improve the LLM\\'s understanding of available tools, resources, etc. It can be thought of like a \"hint\" to the model. For example, this information MAY be added to the system prompt.',\n});\n```\n\n### Sessions\n\nThe `session` object is an instance of `FastMCPSession` and it describes active client sessions.\n\n```ts\nserver.sessions;\n```\n\nWe allocate a new server instance for each client connection to enable 1:1 communication between a client and the server.\n\n### Typed server events\n\nYou can listen to events emitted by the server using the `on` method:\n\n```ts\nserver.on(\"connect\", (event) => {\n  console.log(\"Client connected:\", event.session);\n});\n\nserver.on(\"disconnect\", (event) => {\n  console.log(\"Client disconnected:\", event.session);\n});\n```\n\n## `FastMCPSession`\n\n`FastMCPSession` represents a client session and provides methods to interact with the client.\n\nRefer to [Sessions](#sessions) for examples of how to obtain a `FastMCPSession` instance.\n\n### `requestSampling`\n\n`requestSampling` creates a [sampling](https://modelcontextprotocol.io/docs/concepts/sampling) request and returns the response.\n\n```ts\nawait session.requestSampling({\n  messages: [\n    {\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: \"What files are in the current directory?\",\n      },\n    },\n  ],\n  systemPrompt: \"You are a helpful file system assistant.\",\n  includeContext: \"thisServer\",\n  maxTokens: 100,\n});\n```\n\n#### Options\n\n`requestSampling` accepts an optional second parameter for request options:\n\n```ts\nawait session.requestSampling(\n  {\n    messages: [\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: \"What files are in the current directory?\",\n        },\n      },\n    ],\n    systemPrompt: \"You are a helpful file system assistant.\",\n    includeContext: \"thisServer\",\n    maxTokens: 100,\n  },\n  {\n    // Progress callback - called when progress notifications are received\n    onprogress: (progress) => {\n      console.log(`Progress: ${progress.progress}/${progress.total}`);\n    },\n\n    // Abort signal for cancelling the request\n    signal: abortController.signal,\n\n    // Request timeout in milliseconds (default: DEFAULT_REQUEST_TIMEOUT_MSEC)\n    timeout: 30000,\n\n    // Whether progress notifications reset the timeout (default: false)\n    resetTimeoutOnProgress: true,\n\n    // Maximum total timeout regardless of progress (no default)\n    maxTotalTimeout: 60000,\n  },\n);\n```\n\n**Options:**\n\n- `onprogress?: (progress: Progress) => void` - Callback for progress notifications from the remote end\n- `signal?: AbortSignal` - Abort signal to cancel the request\n- `timeout?: number` - Request timeout in milliseconds\n- `resetTimeoutOnProgress?: boolean` - Whether progress notifications reset the timeout\n- `maxTotalTimeout?: number` - Maximum total timeout regardless of progress notifications\n\n### `clientCapabilities`\n\nThe `clientCapabilities` property contains the client capabilities.\n\n```ts\nsession.clientCapabilities;\n```\n\n### `loggingLevel`\n\nThe `loggingLevel` property describes the logging level as set by the client.\n\n```ts\nsession.loggingLevel;\n```\n\n### `roots`\n\nThe `roots` property contains the roots as set by the client.\n\n```ts\nsession.roots;\n```\n\n### `server`\n\nThe `server` property contains an instance of MCP server that is associated with the session.\n\n```ts\nsession.server;\n```\n\n### Typed session events\n\nYou can listen to events emitted by the session using the `on` method:\n\n```ts\nsession.on(\"rootsChanged\", (event) => {\n  console.log(\"Roots changed:\", event.roots);\n});\n\nsession.on(\"error\", (event) => {\n  console.error(\"Error:\", event.error);\n});\n```\n\n## Running Your Server\n\n### Test with `mcp-cli`\n\nThe fastest way to test and debug your server is with `fastmcp dev`:\n\n```bash\nnpx fastmcp dev server.js\nnpx fastmcp dev server.ts\n```\n\nThis will run your server with [`mcp-cli`](https://github.com/wong2/mcp-cli) for testing and debugging your MCP server in the terminal.\n\n### Inspect with `MCP Inspector`\n\nAnother way is to use the official [`MCP Inspector`](https://modelcontextprotocol.io/docs/tools/inspector) to inspect your server with a Web UI:\n\n```bash\nnpx fastmcp inspect server.ts\n```\n\n## FAQ\n\n### How to use with Claude Desktop?\n\nFollow the guide https://modelcontextprotocol.io/quickstart/user and add the following configuration:\n\n```json\n{\n  \"mcpServers\": {\n    \"my-mcp-server\": {\n      \"command\": \"npx\",\n      \"args\": [\"tsx\", \"/PATH/TO/YOUR_PROJECT/src/index.ts\"],\n      \"env\": {\n        \"YOUR_ENV_VAR\": \"value\"\n      }\n    }\n  }\n}\n```\n\n### How to run FastMCP behind a proxy?\n\nRefer to this [issue](https://github.com/punkpeye/fastmcp/issues/25#issuecomment-3004568732) for an example of using FastMCP with `express` and `http-proxy-middleware`.\n\n## Showcase\n\n> [!NOTE]\n>\n> If you've developed a server using FastMCP, please [submit a PR](https://github.com/punkpeye/fastmcp) to showcase it here!\n\n> [!NOTE]\n>\n> If you are looking for a boilerplate repository to build your own MCP server, check out [fastmcp-boilerplate](https://github.com/punkpeye/fastmcp-boilerplate).\n\n- [apinetwork/piapi-mcp-server](https://github.com/apinetwork/piapi-mcp-server) - generate media using Midjourney/Flux/Kling/LumaLabs/Udio/Chrip/Trellis\n- [domdomegg/computer-use-mcp](https://github.com/domdomegg/computer-use-mcp) - controls your computer\n- [LiterallyBlah/Dradis-MCP](https://github.com/LiterallyBlah/Dradis-MCP) – manages projects and vulnerabilities in Dradis\n- [Meeting-Baas/meeting-mcp](https://github.com/Meeting-Baas/meeting-mcp) - create meeting bots, search transcripts, and manage recording data\n- [drumnation/unsplash-smart-mcp-server](https://github.com/drumnation/unsplash-smart-mcp-server) – enables AI agents to seamlessly search, recommend, and deliver professional stock photos from Unsplash\n- [ssmanji89/halopsa-workflows-mcp](https://github.com/ssmanji89/halopsa-workflows-mcp) - HaloPSA Workflows integration with AI assistants\n- [aiamblichus/mcp-chat-adapter](https://github.com/aiamblichus/mcp-chat-adapter) – provides a clean interface for LLMs to use chat completion\n- [eyaltoledano/claude-task-master](https://github.com/eyaltoledano/claude-task-master) – advanced AI project/task manager powered by FastMCP\n- [cswkim/discogs-mcp-server](https://github.com/cswkim/discogs-mcp-server) - connects to the Discogs API for interacting with your music collection\n- [Panzer-Jack/feuse-mcp](https://github.com/Panzer-Jack/feuse-mcp) - Frontend Useful MCP Tools - Essential utilities for web developers to automate API integration and code generation\n- [sunra-ai/sunra-clients](https://github.com/sunra-ai/sunra-clients/tree/main/mcp-server) - Sunra.ai is a generative media platform built for developers, providing high-performance AI model inference capabilities.\n\n## Acknowledgements\n\n- FastMCP is inspired by the [Python implementation](https://github.com/jlowin/fastmcp) by [Jonathan Lowin](https://github.com/jlowin).\n- Parts of codebase were adopted from [LiteMCP](https://github.com/wong2/litemcp).\n- Parts of codebase were adopted from [Model Context protocolでSSEをやってみる](https://dev.classmethod.jp/articles/mcp-sse/).\n",
  "category": "AI Tools",
  "quality_score": 86,
  "archestra_config": {
    "client_config_permutations": {
      "mcpServers": {
        "fastmcp-stdio": {
          "command": "npx",
          "args": ["-y", "fastmcp", "dev", "src/examples/addition.ts"],
          "env": {}
        },
        "fastmcp-inspect": {
          "command": "npx",
          "args": ["-y", "fastmcp", "inspect", "src/examples/addition.ts"],
          "env": {}
        },
        "fastmcp-http-stream-stateless": {
          "command": "npx",
          "args": [
            "-y",
            "fastmcp",
            "dev",
            "src/server.ts",
            "--transport",
            "http-stream",
            "--port",
            "8080",
            "--stateless",
            "true"
          ],
          "env": {}
        },
        "fastmcp-http-stream-stateless-env": {
          "command": "npx",
          "args": ["-y", "fastmcp", "dev", "src/server.ts"],
          "env": {
            "FASTMCP_STATELESS": "true"
          }
        }
      }
    },
    "oauth": {
      "provider": null,
      "required": false
    }
  },
  "github_info": {
    "owner": "punkpeye",
    "repo": "fastmcp",
    "url": "https://github.com/punkpeye/fastmcp",
    "name": "fastmcp",
    "path": null,
    "stars": 2290,
    "contributors": 32,
    "issues": 86,
    "releases": true,
    "ci_cd": true,
    "latest_commit_hash": "774d1a0332d817f89602a2e1c364a18c6dd35cf1"
  },
  "programming_language": "TypeScript",
  "framework": null,
  "last_scraped_at": "2025-08-04T10:55:15.684Z",
  "evaluation_model": "gemini-2.5-flash",
  "protocol_features": {
    "implementing_tools": true,
    "implementing_prompts": true,
    "implementing_resources": true,
    "implementing_sampling": true,
    "implementing_roots": true,
    "implementing_logging": true,
    "implementing_stdio": true,
    "implementing_streamable_http": true,
    "implementing_oauth2": false
  },
  "dependencies": [
    {
      "name": "@modelcontextprotocol/sdk",
      "importance": 10
    },
    {
      "name": "@standard-schema/spec",
      "importance": 8
    },
    {
      "name": "execa",
      "importance": 6
    },
    {
      "name": "file-type",
      "importance": 5
    },
    {
      "name": "fuse.js",
      "importance": 6
    },
    {
      "name": "mcp-proxy",
      "importance": 8
    },
    {
      "name": "strict-event-emitter-types",
      "importance": 4
    },
    {
      "name": "undici",
      "importance": 7
    },
    {
      "name": "uri-templates",
      "importance": 5
    },
    {
      "name": "xsschema",
      "importance": 6
    },
    {
      "name": "yargs",
      "importance": 7
    },
    {
      "name": "zod",
      "importance": 8
    },
    {
      "name": "zod-to-json-schema",
      "importance": 7
    }
  ],
  "raw_dependencies": "=== package.json ===\n{\n  \"name\": \"fastmcp\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/FastMCP.js\",\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"lint\": \"prettier --check . && eslint . && tsc --noEmit && jsr publish --dry-run\",\n    \"test\": \"vitest run\",\n    \"format\": \"prettier --write . && eslint --fix .\"\n  },\n  \"bin\": {\n    \"fastmcp\": \"dist/bin/fastmcp.js\"\n  },\n  \"keywords\": [\n    \"MCP\",\n    \"SSE\"\n  ],\n  \"type\": \"module\",\n  \"author\": \"Frank Fiegel <frank@glama.ai>\",\n  \"license\": \"MIT\",\n  \"description\": \"A TypeScript framework for building MCP servers.\",\n  \"module\": \"dist/FastMCP.js\",\n  \"types\": \"dist/FastMCP.d.ts\",\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.15.1\",\n    \"@standard-schema/spec\": \"^1.0.0\",\n    \"execa\": \"^9.6.0\",\n    \"file-type\": \"^21.0.0\",\n    \"fuse.js\": \"^7.1.0\",\n    \"mcp-proxy\": \"^5.5.0\",\n    \"strict-event-emitter-types\": \"^2.0.0\",\n    \"undici\": \"^7.11.0\",\n    \"uri-templates\": \"^0.2.0\",\n    \"xsschema\": \"0.3.0-beta.8\",\n    \"yargs\": \"^18.0.0\",\n    \"zod\": \"^3.25.76\",\n    \"zod-to-json-schema\": \"^3.24.6\"\n  },\n  \"repository\": {\n    \"url\": \"https://github.com/punkpeye/fastmcp\"\n  },\n  \"homepage\": \"https://glama.ai/mcp\",\n  \"release\": {\n    \"branches\": [\n      \"main\"\n    ],\n    \"plugins\": [\n      \"@semantic-release/commit-analyzer\",\n      \"@semantic-release/release-notes-generator\",\n      \"@semantic-release/npm\",\n      \"@semantic-release/github\",\n      \"@sebbo2002/semantic-release-jsr\"\n    ]\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"^9.30.1\",\n    \"@modelcontextprotocol/inspector\": \"^0.16.1\",\n    \"@sebbo2002/semantic-release-jsr\": \"^3.0.0\",\n    \"@tsconfig/node22\": \"^22.0.2\",\n    \"@types/node\": \"^24.0.13\",\n    \"@types/uri-templates\": \"^0.1.34\",\n    \"@types/yargs\": \"^17.0.33\",\n    \"@valibot/to-json-schema\": \"^1.3.0\",\n    \"@wong2/mcp-cli\": \"^1.12.0\",\n    \"arktype\": \"^2.1.20\",\n    \"eslint\": \"^9.30.1\",\n    \"eslint-config-prettier\": \"^10.1.5\",\n    \"eslint-plugin-perfectionist\": \"^4.15.0\",\n    \"eslint-plugin-prettier\": \"^5.5.1\",\n    \"eventsource-client\": \"^1.1.3\",\n    \"get-port-please\": \"^3.2.0\",\n    \"jiti\": \"^2.4.2\",\n    \"jsr\": \"^0.13.5\",\n    \"prettier\": \"^3.6.2\",\n    \"semantic-release\": \"^24.2.7\",\n    \"tsup\": \"^8.5.0\",\n    \"typescript\": \"^5.8.3\",\n    \"typescript-eslint\": \"^8.36.0\",\n    \"valibot\": \"^1.1.0\",\n    \"vitest\": \"^3.2.4\"\n  },\n  \"tsup\": {\n    \"entry\": [\n      \"src/FastMCP.ts\",\n      \"src/bin/fastmcp.ts\"\n    ],\n    \"format\": [\n      \"esm\"\n    ],\n    \"dts\": true,\n    \"splitting\": true,\n    \"sourcemap\": true,\n    \"clean\": true\n  }\n}\n"
}
